# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
from baml_py import type_builder
from baml_py import baml_py
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AnimationData","ProblemData",]
        ), enums=set(
          ["Environments","Forces","Interactions","Motions","Objects",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)

    # #########################################################################
    # Generated enums 5
    # #########################################################################

    @property
    def Environments(self) -> "EnvironmentsViewer":
        return EnvironmentsViewer(self)

    @property
    def Forces(self) -> "ForcesViewer":
        return ForcesViewer(self)

    @property
    def Interactions(self) -> "InteractionsViewer":
        return InteractionsViewer(self)

    @property
    def Motions(self) -> "MotionsViewer":
        return MotionsViewer(self)

    @property
    def Objects(self) -> "ObjectsViewer":
        return ObjectsViewer(self)


    # #########################################################################
    # Generated classes 2
    # #########################################################################

    @property
    def AnimationData(self) -> "AnimationDataViewer":
        return AnimationDataViewer(self)

    @property
    def ProblemData(self) -> "ProblemDataViewer":
        return ProblemDataViewer(self)



# #########################################################################
# Generated enums 5
# #########################################################################

class EnvironmentsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Environments")
        self._values: typing.Set[str] = set([  "Cliff",  "Ground",  "Incline",  "Wall",  "PulleySystem",  ])
        self._vals = EnvironmentsValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "EnvironmentsValues":
        return self._vals


class EnvironmentsViewer(EnvironmentsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class EnvironmentsValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def Cliff(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Cliff"))
    
    @property
    def Ground(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Ground"))
    
    @property
    def Incline(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Incline"))
    
    @property
    def Wall(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Wall"))
    
    @property
    def PulleySystem(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PulleySystem"))
    
    


class ForcesAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Forces")
        self._values: typing.Set[str] = set([  "AirResistance",  "AppliedForce",  "BuoyantForce",  "CentripetalForce",  "CoriolisForce",  "ElectricForce",  "FrictionForce",  "GravitationalForce",  "LiftThrustForce",  "MagneticForce",  "NetForce",  "SpringForce",  "TensionForce",  "Torque",  "NormalForce",  ])
        self._vals = ForcesValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ForcesValues":
        return self._vals


class ForcesViewer(ForcesAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ForcesValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def AirResistance(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("AirResistance"))
    
    @property
    def AppliedForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("AppliedForce"))
    
    @property
    def BuoyantForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BuoyantForce"))
    
    @property
    def CentripetalForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CentripetalForce"))
    
    @property
    def CoriolisForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CoriolisForce"))
    
    @property
    def ElectricForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ElectricForce"))
    
    @property
    def FrictionForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FrictionForce"))
    
    @property
    def GravitationalForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GravitationalForce"))
    
    @property
    def LiftThrustForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LiftThrustForce"))
    
    @property
    def MagneticForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MagneticForce"))
    
    @property
    def NetForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NetForce"))
    
    @property
    def SpringForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SpringForce"))
    
    @property
    def TensionForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TensionForce"))
    
    @property
    def Torque(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Torque"))
    
    @property
    def NormalForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NormalForce"))
    
    


class InteractionsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Interactions")
        self._values: typing.Set[str] = set([  "Buoyancy",  "Collision",  "DragForce",  "ElectrostaticForce",  "Friction",  "Gravity",  "MagneticForce",  "NormalForce",  "SpringForce",  "Tension",  ])
        self._vals = InteractionsValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "InteractionsValues":
        return self._vals


class InteractionsViewer(InteractionsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class InteractionsValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def Buoyancy(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Buoyancy"))
    
    @property
    def Collision(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Collision"))
    
    @property
    def DragForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DragForce"))
    
    @property
    def ElectrostaticForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ElectrostaticForce"))
    
    @property
    def Friction(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Friction"))
    
    @property
    def Gravity(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Gravity"))
    
    @property
    def MagneticForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MagneticForce"))
    
    @property
    def NormalForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NormalForce"))
    
    @property
    def SpringForce(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SpringForce"))
    
    @property
    def Tension(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Tension"))
    
    


class MotionsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Motions")
        self._values: typing.Set[str] = set([  "CombinedTransRotMotion",  "DampedOscillation",  "LinearMotion",  "ProjectileMotion2D",  "ProjectileMotion3D",  "RelativeMotion",  "ResistiveMotion",  "RotationalMotion",  "SimpleHarmonicMotion",  "UniformCircularMotion",  ])
        self._vals = MotionsValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "MotionsValues":
        return self._vals


class MotionsViewer(MotionsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class MotionsValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def CombinedTransRotMotion(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CombinedTransRotMotion"))
    
    @property
    def DampedOscillation(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DampedOscillation"))
    
    @property
    def LinearMotion(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LinearMotion"))
    
    @property
    def ProjectileMotion2D(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ProjectileMotion2D"))
    
    @property
    def ProjectileMotion3D(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ProjectileMotion3D"))
    
    @property
    def RelativeMotion(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RelativeMotion"))
    
    @property
    def ResistiveMotion(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ResistiveMotion"))
    
    @property
    def RotationalMotion(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RotationalMotion"))
    
    @property
    def SimpleHarmonicMotion(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SimpleHarmonicMotion"))
    
    @property
    def UniformCircularMotion(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("UniformCircularMotion"))
    
    


class ObjectsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Objects")
        self._values: typing.Set[str] = set([  "Object",  ])
        self._vals = ObjectsValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ObjectsValues":
        return self._vals


class ObjectsViewer(ObjectsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ObjectsValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def Object(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("Object"))
    
    



# #########################################################################
# Generated classes 2
# #########################################################################

class AnimationDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AnimationData")
        self._properties: typing.Set[str] = set([  "forces",  "interactions",  "motions",  "objects",  "environments",  ])
        self._props = AnimationDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AnimationDataProperties":
        return self._props


class AnimationDataViewer(AnimationDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AnimationDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def forces(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("forces"))
    
    @property
    def interactions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("interactions"))
    
    @property
    def motions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("motions"))
    
    @property
    def objects(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("objects"))
    
    @property
    def environments(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("environments"))
    
    


class ProblemDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ProblemData")
        self._properties: typing.Set[str] = set([  "problem",  "stepByStep",  "formulas",  "solution",  ])
        self._props = ProblemDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ProblemDataProperties":
        return self._props


class ProblemDataViewer(ProblemDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ProblemDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def problem(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("problem"))
    
    @property
    def stepByStep(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("stepByStep"))
    
    @property
    def formulas(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("formulas"))
    
    @property
    def solution(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("solution"))
    
    

